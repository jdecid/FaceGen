import itertools
import os
import random

import matplotlib.pyplot as plt
import numpy as np
import torch
from torchvision.transforms import Normalize

from models.evolutionary.face_classifier import FaceClassifier
from utils.train_constants import GA_IMG_SIZE

"""
This work introduces a simple project called GARI (Genetic Algorithm for Reproducing Images).
GARI reproduces a single image using Genetic Algorithm (GA) by evolving pixel values.

This project works with both color and gray images without any modifications.
Just give the image path.
Using three parameters, we can customize it to statisfy our need. 
The parameters are:
    1) Population size. I.e. number of individuals pepr population.
    2) Mating pool size. I.e. Number of selected parents in the mating pool.
    3) Mutation percentage. I.e. number of genes to change their values.

Value encoding used for representing the input.
Crossover is applied by exchanging half of genes from two parents.
Mutation is applied by randomly changing the values of randomly selected 
predefined percent of genes from the parents chromosome.

This project is implemented using Python 3.5 by Ahmed F. Gad.
Contact info:
ahmed.fawzy@ci.menofia.edu.eg
https://www.linkedin.com/in/ahmedfgad/
"""


def initial_population(n_individuals=8):
    """Creating an initial population randomly."""
    return torch.randint(size=(n_individuals, 3 * GA_IMG_SIZE * GA_IMG_SIZE), low=0, high=256)


def cal_pop_fitness(pop: torch.Tensor, model: FaceClassifier):
    """
    This method calculates the fitness of all solutions in the population.
    """
    images = pop.view(pop.size(0), 3, GA_IMG_SIZE, GA_IMG_SIZE)
    normalized_images = Normalize(mean=(0.5, 0.5, 0.5), std=(0.5, 0.5, 0.5))(images.float() / 255.0)
    fitness = model(normalized_images)
    return fitness.cpu().detach()


def select_mating_pool(population, qualities, num_parents):
    """
    Selects the best individuals in the current generation, according to the 
    number of parents specified, for mating and generating a new better population.
    """
    parents = torch.empty(size=(num_parents, population.size(1)), dtype=torch.uint8)
    for parent_num in range(num_parents):
        # Retrieving the best unselected solution.
        max_quality_idx = torch.argmax(qualities)
        # Appending the currently selected
        parents[parent_num, :] = population[max_quality_idx, :]
        """
        Set quality of selected individual to a negative value to not get 
        selected again. Algorithm calculations will just make qualities >= 0.
        """
        qualities[max_quality_idx] = -1
    return parents


def crossover(parents, n_individuals=8):
    """
    Applying crossover operation to the set of currently selected parents to 
    create a new generation.
    """
    new_population = torch.empty(size=(n_individuals, 3 * GA_IMG_SIZE * GA_IMG_SIZE), dtype=torch.uint8)

    """
    Selecting the best previous parents to be individuals in the new generation.

    **Question** Why using the previous parents in the new population?
    It is recommended to use the previous best solutions (parents) in the new 
    generation in addition to the offspring generated from these parents and 
    not use just the offspring.
    The reason is that the offspring may not produce the same fitness values 
    generated by their parents. Offspring may be worse than their parents.
    As a result, if none of the offspring are better, the previous generations 
    winners will be reselected until getting a better offspring.
    """
    # Previous parents (best elements).
    new_population[0:parents.size(0), :] = parents

    # Getting how many offspring to be generated. If the population size is 8 and number of
    # parents mating is 4, then number of offspring to be generated is 4.
    num_newly_generated = n_individuals - parents.size(0)
    # Getting all possible permutations of the selected parents.
    parents_permutations = list(itertools.permutations(iterable=np.arange(0, parents.size(0)), r=2))
    # Randomly selecting the parents permutations to generate the offspring.
    selected_permutations = random.sample(range(len(parents_permutations)),
                                          num_newly_generated)

    comb_idx = parents.size(0)
    for comb in range(len(selected_permutations)):
        # Generating the offspring using the permutations previously selected randomly.
        selected_comb_idx = selected_permutations[comb]
        selected_comb = parents_permutations[selected_comb_idx]

        # Applying crossover by exchanging half of the genes between two parents.
        half_size = new_population.size(1) // 2
        new_population[comb_idx + comb, 0:half_size] = parents[selected_comb[0],
                                                       0:half_size]
        new_population[comb_idx + comb, half_size:] = parents[selected_comb[1],
                                                      half_size:]

    return new_population


def mutation(population, num_parents_mating, mut_percent):
    """
    Applying mutation by selecting a predefined percent of genes randomly.
    Values of the randomly selected genes are changed randomly.
    """
    for idx in range(num_parents_mating, population.size(0)):
        if torch.rand() < 0.6:
            # A predefined percent of genes are selected randomly.
            rand_selected_idx = mut_percent * population.size(1)
            rand_idx = torch.randint(size=(rand_selected_idx,), low=0, high=256)
            # Changing the values of the selected genes randomly.
            new_values = torch.randint(size=(rand_idx.size(0),), low=0, high=256)
            # new_values = np.random.normal(loc=0.0, scale=1.0, size=rand_idx.size(0])
            # Updating population after mutation.
            population[idx, rand_idx] = new_values
    return population


def save_images(curr_iteration, new_population, model, save_point, save_dir, log_tag):
    """
    Saving best solution in a given generation as an image in the specified directory.
    Images are saved according to stop points to avoid saving images from
    all generations as saving many images will make the algorithm slow.
    """
    qualities = cal_pop_fitness(new_population, model)
    if np.mod(curr_iteration, save_point) == 0:
        # Selecting best solution (chromosome) in the generation.
        best_solution_chromosome = new_population[torch.argmax(qualities), :]
        # Decoding the selected chromosome to return it back as an image.
        best_solution_img = best_solution_chromosome.view(3, GA_IMG_SIZE, GA_IMG_SIZE)
        # Saving the image in the specified directory.
        path = os.path.join(save_dir, f'GA_results_{log_tag}')
        if not os.path.exists(path):
            os.mkdir(path)
        plt.imsave(os.path.join(path, f'solution_{curr_iteration}_{np.max(qualities)}.jpg'),
                   best_solution_img.transpose(1, 2, 0))
